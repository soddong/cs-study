# 목차

1) 개념

2) 구현

3) 예상 질문

# 개념

# 기초 정렬
### 버블 정렬 (성능: ... )
배열내 **인접한 두개의 인덱스를 비교**하여 더 큰 숫자를 뒤로 보내어 정렬하는 방법 

* 시간 복잡도  
최선, 평균, 최악 : (n-1) + (n-2) + (n-3) + .... + 2 + 1 -> n(n-1)/2 = O(n^2)

* 공간 복잡도  
O(n) (제자리 정렬) -- 매싸이클마다 n번 swap

### 선택 정렬 (성능: ⭐)
배열을 순회하면서 **현재 위치에 들어갈 원소를 선택**하여 정렬하는 방법

* 시간 복잡도  
최선, 평균, 최악 : (n-1) + (n-2) + (n-3) + .... + 2 + 1 -> n(n-1)/2 = O(n^2)

* 공간 복잡도  
O(n) (제자리 정렬) -- 매싸이클마다 1번 swap

### 삽입 정렬 (성능: ⭐⭐)
정렬된 앞의 인덱스들과 비교하여 **자신의 자리를 찾아 삽입**하여 정렬하는 방법

* 시간 복잡도  
최선 : O(n)  
평균, 최악 : (n-1) + (n-2) + (n-3) + .... + 2 + 1 -> n(n-1)/2 = O(n^2)

* 공간 복잡도  
O(n) (제자리 정렬)



# 개선된 정렬
### 퀵 정렬 (성능: ⭐⭐⭐)
피벗(pivot)을 선택하고 피벗을 기준으로 작은 원소는 왼쪽, 큰 원소는 오른쪽으로 분할하여 정렬하는 방법

* 시간 복잡도  
최선: O(n log n) - 피벗 선택 시 항상 중간 값이 되는 경우  
평균: O(n log n)  
최악: O(n^2) - 피벗 선택이 항상 최대값 또는 최소값일 경우  

* 공간 복잡도
O(log n) - 재귀 호출에 따른 스택 사용

### 머지 정렬 (성능: ⭐⭐⭐)
배열을 반으로 나누어 각각을 정렬하고, 정렬된 부분 배열을 합쳐 전체를 정렬하는 방법

시간 복잡도:

최선, 평균, 최악: O(n log n)
공간 복잡도:

O(n) - 추가적인 배열이 필요함

### 힙 정렬 (성능: ⭐⭐⭐)
최대 힙 또는 최소 힙을 구성하고, 힙에서 루트를 제거하면서 정렬하는 방법

시간 복잡도:

최선, 평균, 최악: O(n log n)
공간 복잡도:

O(1) - 제자리 정렬

# 심화 정렬


### radix?

언어별로 어떤 sort? — 자바, c++, python

# 구현

git ㄱㄱ

### 시간차이

- 

# 참고

# 예상 질문

- 
    
